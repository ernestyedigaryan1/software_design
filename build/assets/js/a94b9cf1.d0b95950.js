"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[27],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:4},i="4. Type classes and ADTs",s={unversionedId:"functional-programming/type_classes",id:"functional-programming/type_classes",title:"4. Type classes and ADTs",description:"Another important thing in functional programming is type-classes and algebraic data types. This is what makes functional programming so flexible and abstract by providing a convenient way of using ad-hoc polymorphism. Actually, we already dealt with it in the previous article when talked about the functors.",source:"@site/docs/4-functional-programming/type_classes.md",sourceDirName:"4-functional-programming",slug:"/functional-programming/type_classes",permalink:"/docs/functional-programming/type_classes",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"3. Categories and Functors",permalink:"/docs/functional-programming/categories_and_functors"},next:{title:"5. Functional programming in JS/TS",permalink:"/docs/functional-programming/is_js_functional"}},l={},p=[{value:"4.1 Type classes",id:"41-type-classes",level:2},{value:"4.2 Algebraic data types",id:"42-algebraic-data-types",level:2},{value:"4.3 Further reading",id:"43-further-reading",level:2},{value:"4.4 New version of the initial example",id:"44-new-version-of-the-initial-example",level:2},{value:"4.5 What&#39;s the point of all of it?",id:"45-whats-the-point-of-all-of-it",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"4-type-classes-and-adts"},"4. Type classes and ADTs"),(0,o.kt)("p",null,"Another important thing in functional programming is type-classes and algebraic data types. This is what makes functional programming so flexible and abstract by providing a convenient way of using ad-hoc polymorphism. Actually, we already dealt with it in the previous article when talked about the ",(0,o.kt)("inlineCode",{parentName:"p"},"functors"),"."),(0,o.kt)("h2",{id:"41-type-classes"},"4.1 Type classes"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Type class")," is a pattern used to achieve ad-hoc polymorphism. In general, it allows us to create generic type for provided list of operations, associated with a particular type, and this type is determined by parametric polymorphism."),(0,o.kt)("p",null,"Sounds complex, but let's see with examples. Here's an example of a function that compares two strings:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.1 - Equality function for simple type"',title:'"Listing',"4.1.1":!0,"-":!0,Equality:!0,function:!0,for:!0,simple:!0,'type"':!0},"const eqString = (a: string, b: string) => a === b;\n")),(0,o.kt)("p",null,"Okay, that's work. But what if we want to create more complex types?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.2 - Equality function for more complex type"',title:'"Listing',"4.1.2":!0,"-":!0,Equality:!0,function:!0,for:!0,more:!0,complex:!0,'type"':!0},"type Student = { \n  name: string;\n  score: number;\n};\n\nconst eqStudents = (a: Student, b: Student) => a.score === b.score && a.name === b.name;\nconst eqStudentsScore = (a: Student, b: Student) => a.score === b.score;\n")),(0,o.kt)("p",null,"How can we generalize such an operation? We can create a type for it!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.3 - Equality function type"',title:'"Listing',"4.1.3":!0,"-":!0,Equality:!0,function:!0,'type"':!0},"type Equals = <T>(a: T, b: T) => boolean;\n")),(0,o.kt)("p",null,"Seems okay. But, what if we want not just to compare whether they are equal, but to additionally determine if one of them is greater or less? So, we would need to have two functions: ",(0,o.kt)("inlineCode",{parentName:"p"},"equals")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"compare"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=\"4.1.5 - 'equal' and 'compare' functions for complex type\"",title:'"4.1.5',"-":!0,"'equal'":!0,and:!0,"'compare'":!0,functions:!0,for:!0,complex:!0,'type"':!0},"const eqStudentsScore = (a: Student, b: Student) => a.score === b.score;\nconst compareStudentsScore = (a: Student, b: Student) => a.score === b.score\n  ? 0\n  : a.score > b.score\n    ? 1\n    : -1;\n")),(0,o.kt)("p",null,"These two functions are interconnected, but in the current implementation, they are separate, which in some cases is not convenient."),(0,o.kt)("p",null,"And here are the ",(0,o.kt)("em",{parentName:"p"},"type-classes")," that come into the game! We can create a type constructor for such operations. Let's start with equality:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.6 - Setoid type-class"',title:'"Listing',"4.1.6":!0,"-":!0,Setoid:!0,'type-class"':!0},"// In some languages and mathematics it's called Setoid\ninterface Eq<T> {\n  equals(a: T, b: T): boolean;\n}\n\nconst eqNumber: Eq<number> = {\n  equals: (a, b) => a === b,\n};\n")),(0,o.kt)("p",null,"For now, the benefits are not so obvious. Let's proceed and build comparing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.7 - Ord type-class"',title:'"Listing',"4.1.7":!0,"-":!0,Ord:!0,'type-class"':!0},"enum Ordering {\n  LESS = -1,\n  EQUALS = 0,\n  GREATER = 1,\n}\n\ninterface Ord<T> extends Eq<T> {\n  compare: (a: T, b: T) => Ordering,\n}\n\nconst byStudentScore: Ord<Student> = {\n  compare: (a, b) => a.score === b.score\n    ? Ordering.EQUALS\n    : a.score > b.score\n      ? Ordering.GREATER\n      : Ordering.LESS,\n  equals: (a, b) => a.score === b.score,\n};\n")),(0,o.kt)("p",null,"Great! But such a way of creating new instances of ",(0,o.kt)("inlineCode",{parentName:"p"},"Ord")," is exhausting, and thanks to a such simple abstraction of ",(0,o.kt)("inlineCode",{parentName:"p"},"Ord"),", we can handle it. Let's create a ",(0,o.kt)("inlineCode",{parentName:"p"},"contramap")," utility  (",(0,o.kt)("a",{parentName:"p",href:"https://ncatlab.org/nlab/show/contravariant+functor"},"Contravariant Functor"),")."),(0,o.kt)("p",null,"Try in playground: ",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgKIEcA8AVAfMgbwChlkJ0BXOAGwGcAKOALmWwBpkAjF7AShc4B7QdQhwQAbiIBfIkQggKAW2QB5KABNooAOaESyADKoAyieQBeZAFoAjGwOoAigFUAgofNWADA9IBxACVUN2xUQMtkexk5UEhYRBR1DRx8CAAPSBANWjQsPH1SBEElAAc4KAgWRh4OblZeS3xk7RAdB1kiYpBaMGRBTQA5ZU5oFmTMRSVRqHwrYiKS8srquDrGi3w4SwsrTgNSAH41TVadADpnd08D5BZt-H3SZ+Rjlqhdc6CQsMDb0nGpw+bXOxjMfjIlBotFW6yayG2uz2HSkRAA9GjkABNQQUZDlWi5MAACxQMAoIAQYGAghAyBgA2QYCg4loDKgSl0yDcTMEyAAQhxxBomaS6RN+bhzshBoIAO7IACeuOQxLgADckppMG5cF1ab1kN1mXAlHBSpEdRxJfQYKsWG4Nvh+U7kPQBhpASlJfwTildfD6AtIVQ6LCuK6PedyKGGDBGLwOPHOLxEwZimUKlU3WsI-CoxnlhBbQmk-QU2npLxUWBFaUUCYwBQtOBIgRkCBTdnesD2shaMUVh2RtBkNIpN1DZxFY3mwowCZB9mJrOW2A5kbaSazaV6AZ6L05+AWKv567D2vzgOBigMfSKVSaXSwHyd8hT63rPgpjMiLx3UMI5QNWyB3sk9KMoWFRcmAcp8j+0C0HIk59Be865FYADaBjtp2SjZgA5AAUoIxIgARHDXkOtjeGOEK4V2LDEeIEAUf2S4sAArHROEdoxyDMQgADWbFUdmADsPEALoTgaqEDJAIpYecKloeAtBSVeCnljOTZrouN7nFBlTVshBoiBA5zUIIOgHgpEAaLwQA"},"Listing 4.1.8 Creating Ord with contramap constructor")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1.8 - Creating Ord with contramap constructor"',title:'"Listing',"4.1.8":!0,"-":!0,Creating:!0,Ord:!0,with:!0,contramap:!0,'constructor"':!0},"const ordNumber: Ord<number> = {\n  compare: (a, b) => a === b\n    ? Ordering.EQUALS\n    : a > b\n      ? Ordering.GREATER\n      : Ordering.LESS,\n  equals: (a, b) => a === b,\n};\n\n// You pass the function for transforming A to B, and then Ord<B>. Now you have Ord<A>\nconst contramap = <A, B>(f: (a: A) => B) => (ord: Ord<B>): Ord<A> => ({\n  equals: (a, b) => ord.equals(f(a), f(b)),\n  compare: (a, b) => ord.compare(f(a), f(b)),\n});\n\nconst byStudentScore: Ord<Student> = contramap(\n  (student) => student.score // function to map Student -> number\n)(ordNumber); // Ord for comparing two numbers\n\nconst students = [\n  { name: 'John', score: 10 },\n  { name: 'Jane', score: 5 },\n  { name: 'Jack', score: 7 },\n];\nconst sorted = [...students].sort(byStudentScore.compare);\n")),(0,o.kt)("p",null,"Some info about ",(0,o.kt)("inlineCode",{parentName:"p"},"contramap"),": It's a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors"},"contravariant")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"Functor.map"),". When ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," makes ",(0,o.kt)("inlineCode",{parentName:"p"},"F<A> -> F<B>")," transformation using morphism ",(0,o.kt)("inlineCode",{parentName:"p"},"A -> B"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"contramap")," makes ",(0,o.kt)("inlineCode",{parentName:"p"},"F<A> -> F<B>")," transformation using morphism ",(0,o.kt)("inlineCode",{parentName:"p"},"B -> A"),". Here's a very demonstrative example of how contravariance works: ",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/66410115/difference-between-variance-covariance-contravariance-and-bivariance-in-typesc"},"stackoverflow"),"."),(0,o.kt)("p",null,"And this is only a small part of the huge number of possibilities that these abstractions provide."),(0,o.kt)("p",null,"We already worked with another type-class in the previous chapter - ",(0,o.kt)("inlineCode",{parentName:"p"},"Functors"),", it has only one operator: ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", but you can create from it more complex abstractions, like ",(0,o.kt)("inlineCode",{parentName:"p"},"Monad"),"."),(0,o.kt)("p",null,"You can check the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fantasyland/fantasy-land"},"full list of type-classes"),": (it's called there an algebraic structure, it's another concept from math, just a non-empty set with some operations and laws)."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Do not be afraid if you don't understand it, this is a specification for library creators, not educational purposes.")),(0,o.kt)("p",null,"Type classes are pretty similar to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Strategy")," pattern from OOP (that we will explore later). Some algorithms are put inside one class and form a family, where distinct instances of different classes of the same strategy are interchangeable."),(0,o.kt)("h2",{id:"42-algebraic-data-types"},"4.2 Algebraic data types"),(0,o.kt)("p",null,"By definition, an algebraic data type is a composite data type formed by combining other types using ",(0,o.kt)("inlineCode",{parentName:"p"},"sum")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," techniques."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," type is just a bounded combination of types, for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"Record")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Tuple"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"sum")," type is also called ",(0,o.kt)("inlineCode",{parentName:"p"},"disjoin union"),", some combination of different types, like ",(0,o.kt)("inlineCode",{parentName:"p"},"type DisjoinUnion = A | B")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.2.1 - ADTs"',title:'"Listing',"4.2.1":!0,"-":!0,'ADTs"':!0},"type Product = { a: string; b: number };\ntype Sum = string | number;\ntype ADTs = Product & Sum;\n")),(0,o.kt)("p",null,"It's pretty simple. And from here, we might want to combine polymorphism of type-classes and ADTs to achieve huge flexibility. For example, let's take the ",(0,o.kt)("inlineCode",{parentName:"p"},"disjoin union")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"Value | null"),", and transform it into ",(0,o.kt)("inlineCode",{parentName:"p"},"Functor"),". How can we do that?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.2.2 - Maybe ADT"',title:'"Listing',"4.2.2":!0,"-":!0,Maybe:!0,'ADT"':!0},"type None = {\n  _type: 'None',\n}\n\ntype Some<A> = {\n  _type: 'Some',\n  value: A,\n}\n\nconst isSome = <T>(optional: Maybe<T>): optional is Some<T> => optional._type === 'Some';\nconst some = <T>(value: T): Some<T> => ({\n  _type: 'Some',\n  value,\n});\nconst none = {\n  _type: 'None'\n};\n\ntype Maybe<A> = Some<A> | None;\n\n// @type Functor<Maybe>\nconst maybeFunctor = {\n  map: <A, B>(fa: (a: A) => B) => (m: Maybe<A>): Maybe<B> => (\n    isSome(m) ? some(fa(m)) : none\n  )\n} \n")),(0,o.kt)("p",null,"Yeah, we have already seen this before, and now let's look deeply into it. Here, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Maybe")," functor is just a casual ",(0,o.kt)("inlineCode",{parentName:"p"},"value | null")," which we often use, but it is transformed into such a shape, so we can apply it to different type-classes. We can transform it into the ",(0,o.kt)("inlineCode",{parentName:"p"},"Monad"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Foldable"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Traversable"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Apply"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Applicative"),' and many other different interesting concepts. You might have a question: "So, is ',(0,o.kt)("inlineCode",{parentName:"p"},"Maybe"),' a type-class or an ADT?" - the answer is "Both". Type class is a type system, or roughly saying in OOP terms - a pattern. ADT is a composite type, which is formed by combining other types. And we can combine them together to achieve huge flexibility.'),(0,o.kt)("h2",{id:"43-further-reading"},"4.3 Further reading"),(0,o.kt)("p",null,"Type classes and Algebraic data types are essential, but complex aspects of functional programming and an explanation above can give you only a blurry understanding of them. If you are interested to learn more - we recommend you to read ",(0,o.kt)("a",{parentName:"p",href:"https://jrsinclair.com/articles/2019/what-i-wish-someone-had-explained-about-functional-programming/"},"this series of articles")),(0,o.kt)("p",null,"Also, you are ready to learn about another technique for handling side effects that we mentioned in the beginning. It's the ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect")," functor! In simple terms, it's an ADT for eventually computed values."),(0,o.kt)("p",null,"Try in on sandbox: ",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/effect-functor-kcriyr?file=/src/index.ts"},"Listing 4.3.1 - Effect ADT")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.3.1 - Effect ADT and a usage example with fp-ts library"',title:'"Listing',"4.3.1":!0,"-":!0,Effect:!0,ADT:!0,and:!0,a:!0,usage:!0,example:!0,with:!0,"fp-ts":!0,'library"':!0},"import { contramap } from 'fp-ts/Ord';\nimport { Ord as ordNumber } from 'fp-ts/number';\nimport { pipe } from 'fp-ts/function';\nimport { sort, tail, filter } from 'fp-ts/Array';\n\ntype Effect<A> = {\n  run: () => A;\n};\n\n// @type Functor<Effect>\nconst effectFunctor = {\n  map: <A, B>(fa: (a: A) => B) => (m: Effect<A>): Effect<B> => ({\n    run: () => fa(m.run()),\n  })  \n}\n\ntype DatabaseResponse<V> = { response: V };\ntype User = { name: string; age: number };\n\nconst getUsers = (): Effect<DatabaseResponse<Array<User>>> => ({\n  run: () => {\n    console.log('performing database request...');\n    return {\n      response: [\n        { name: 'James', age: 23 },\n        { name: 'Jhone', age: 14 },\n      ]\n    };\n  },\n});\n\n// pipe is just like compose, but left to right and the first argument is an _argument_ which would be passed to the first _function_\nconst users = pipe(\n  getUsers(), // _argument_\n  effectFunctor.map((query) => query.response), // _function_\n);\n\nconst byAge = pipe(\n  ordNumber,\n  contramap((user: User) => user.age),\n);\nconst oldestUser = pipe(\n  users,\n  effectFunctor.map(sort(byAge)), // sort array by age\n  effectFunctor.map(tail), // get first element\n);\n\nconst onlyAbove18 = pipe(users, effectFunctor.map(filter((user) => user.age >= 18)));\n")),(0,o.kt)("p",null,"So, what is it all about? The trick is that we already have a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"users"),", an ",(0,o.kt)("inlineCode",{parentName:"p"},"oldestUser"),", and a list of all users above 18, BUT! No side effect was called! If you run this code and look at the console, there would be no output. Database call would be called only when ",(0,o.kt)("inlineCode",{parentName:"p"},".run")," would be called. With this Functor, we can do whatever we want with impure values without even having them. Our code is pure until the moment when we call ",(0,o.kt)("inlineCode",{parentName:"p"},"run"),"."),(0,o.kt)("p",null,"Such an effect system gives us so much power, but it is not apparent at first glance. It allows us to make ",(0,o.kt)("inlineCode",{parentName:"p"},"programs as values"),". Every piece of our logic is just a value, and these values are composed into programs, which are values as well, and we can compose these small programs together to create one big program, which is as well pure and predicted. And then, in the end, in an isolated place, it runs. You might see quite a similar concept in React.js (the application would render only after the ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactDOM.render")," call) and Express.js (the server would start only after the ",(0,o.kt)("inlineCode",{parentName:"p"},".listen")," call)."),(0,o.kt)("p",null,"This is a hard topic as well, so if you are interested, we recommend you to read ",(0,o.kt)("a",{parentName:"p",href:"https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/"},"this article"),"."),(0,o.kt)("h2",{id:"44-new-version-of-the-initial-example"},"4.4 New version of the initial example"),(0,o.kt)("p",null,"Now we know the basics of functional programming, let's rewrite our ",(0,o.kt)("inlineCode",{parentName:"p"},"Listing 1.2")," to something more ",(0,o.kt)("em",{parentName:"p"},"functional"),", using functors and ADTs. We will use the ",(0,o.kt)("a",{parentName:"p",href:"https://gcanti.github.io/fp-ts/"},"fp-ts")," library."),(0,o.kt)("p",null,"You can find the source here: ",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/listing-4-4-1-rework-of-listing-1-2-0r4qvn?file=/src/main.ts"},"Listing 4.4.1 - Rework of Listing 1.2")),(0,o.kt)("p",null,"This code might seem very complex at first glance, but it represents real-world functional programming well."),(0,o.kt)("p",null,"The project consists of 2 main parts: ",(0,o.kt)("inlineCode",{parentName:"p"},"main.ts")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts"),". The main logic of the program is in the ",(0,o.kt)("inlineCode",{parentName:"p"},"main.ts")," file; it has a ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function which implements desired behaviour by taking ",(0,o.kt)("inlineCode",{parentName:"p"},"Student[]")," and returning ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),". There are a lot of interesting examples of using functors, monads and ADTs, so we recommend you read them carefully."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="file: main.ts"',title:'"file:','main.ts"':!0},'import * as E from "fp-ts/Either";\nimport * as N from "fp-ts/number";\nimport * as NEA from "fp-ts/NonEmptyArray";\nimport * as A from "fp-ts/Array";\nimport { contramap } from "fp-ts/Ord";\nimport { pipe, flow } from "fp-ts/function";\n\n// Data\n\nexport type Student = {\n  name: string;\n  score: number;\n  class: "A" | "B";\n};\n\n// Utils\n\nconst byStudentScore = pipe(\n  N.Ord,\n  // Contramap is suited for building Ord for different types. Like here, we build Ord<Student>\n  // https://gcanti.github.io/fp-ts/modules/Ord.ts.html#contramap\n  contramap((student: Student) => student.score)\n);\n\nconst toNonEmptyArray = <L, R>(onEmpty: () => L) => (\n  arr: Array<R>\n): E.Either<L, NEA.NonEmptyArray<R>> =>\n  pipe(NEA.fromArray(arr), E.fromOption(onEmpty));\n\nconst sumScore = pipe(\n  (student: Student) => student.score, // student -> number\n  NEA.foldMap(N.SemigroupSum) // reducing and maping at the same time!\n);\n\nconst tailAndHead = <T>(list: NEA.NonEmptyArray<T>): [T, T] => [\n  list[0],\n  list[list.length - 1]!\n];\n\n// Implementation\n\nexport const main: (\n  students: Array<Student>\n) => E.Either<string, string> = flow(\n  // Converting list from input to the NonEmptyArray\n  toNonEmptyArray<string, Student>(() => "The list of students is empty!"),\n  // Filtering by class A. Since we might face the issue when after filtering, there is no students - a new error might appear\n  // That\'s why we use flatMap to flat Either<*emptyListErr, Either<noAClassStudents, students>> to just Either<emptyListErr|noAClassStudents, students>\n  // That is what the Monad is\n  // * It\'s not the real types, just the meaning of the value inside the Either \n  E.flatMap(\n    flow(\n      A.filter((student) => student.class === "A"),\n      toNonEmptyArray(() => \'There is no students from the "A" class\')\n    )\n  ),\n  // And then we map our Either<err, _students_> to Either<err, _message_>\n  E.map(\n    flow(\n      // Firstly we sort students\n      NEA.sort(byStudentScore),\n      // Then create a tuple of (averageScore, (lowestPerformer, highestPerformer))\n      (sortedStudents) =>\n        [\n          // Average score\n          (sumScore(sortedStudents) / sortedStudents.length).toFixed(2),\n          // Highest and lowest performers\n          tailAndHead(sortedStudents)\n        ] as const,\n      // And finally produce the resulting message\n      ([average, [lowest, highest]]) => `\\\nClass "A":\nThe highest score has: ${highest.name}, score: ${highest.score}\nThe lowest score has: ${lowest.name}, score: ${lowest.score}\nAn average score is ${average}`\n    )\n  )\n);\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts"),' file is a place where we run our program. It implements asking the "database", calling the ',(0,o.kt)("inlineCode",{parentName:"p"},"main")," function, and printing the result to the browser (in DOM) or the console based on the passed parameter. You can find here a good example of using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Effect")," (in the context of fp-ts ",(0,o.kt)("inlineCode",{parentName:"p"},"IO"),") and ",(0,o.kt)("inlineCode",{parentName:"p"},"Task")," monad and the overall approach of writing effect-full code ",(0,o.kt)("inlineCode",{parentName:"p"},"purely"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="file: index.ts"',title:'"file:','index.ts"':!0},'import { flow, pipe } from "fp-ts/function";\nimport * as T from "fp-ts/Task";\nimport * as TE from "fp-ts/TaskEither";\nimport * as IO from "fp-ts/IO";\nimport * as IOE from "fp-ts/lib/IOEither";\nimport * as E from "fp-ts/Either";\n\nimport { Student, main } from "./main";\n\nconst fetchFromDB: TE.TaskEither<string, Array<Student>> = T.delay(200)(\n  TE.right([\n    { name: "Jhon", score: 70, class: "B" },\n    { name: "James", score: 60, class: "A" },\n    { name: "Jones", score: 67, class: "A" },\n    { name: "Raul", score: 55, class: "A" }\n  ])\n  // You can replace it with the "left" to see an error message\n  // TE.left(\'DB: connection refused\')\n);\n\n// DOM manipulation\nconst getEl = (id: string): IOE.IOEither<string, HTMLElement> =>\n  flow(\n    () => document.getElementById(id),\n    E.fromNullable(`DOM: There is no such #${id} element`)\n  );\n\nconst printTo = (id: string) => (content: string) =>\n  pipe(\n    getEl(id),\n    IOE.map((el) => {\n      el.innerText = content;\n    })\n  );\n\n// console manipulation\nconst logAs = (type: "message" | "error") => (\n  message: string\n): IO.IO<void> => () => {\n  // Since all this function is an effect, it\'s absolutely okay to use imperative constructions like "if"\n  if (type === "error") console.error(message);\n  else console.log(message);\n};\nconst logMessage = logAs("message");\nconst logError = logAs("error");\n// You can as well change output channel to the DOM\n/*\nconst logError = flow(\n  printTo("error"),\n  // Since accessing the DOM can produce error, we need to reduce our IOEither to IO\n  IOE.getOrElse(logAs("error")),\n);\n*/\n\nconst print = (to: "DOM" | "console") => (\n  content: string\n): IOE.IOEither<string, void> =>\n  to === "DOM"\n    ? // You can try to replace "app" with another non-existing ID and see an error in the console\n    printTo("app")(content)\n    : // We need to lift IO to IOEither here\n    IOE.fromIO(logMessage(content));\n\n// The program\n\n// The essence of the program - it returns some IO, effectful computation, in our case it\'s printing to the console or the DOM \n// Here we just fetch the data from the "database", push it to the "main" function and then print the result\nconst program: T.Task<IO.IO<void>> = pipe(\n  // fetch our students from "database"\n  fetchFromDB,\n  TE.match(\n    // In case of db error return error logger\n    logError,\n    flow(\n      main,\n      // In case if everything was okay - print result to the DOM\n      E.map(print("DOM")),\n      // At this moment, we have Either<studentsError, IOEither<printError, void>>\n      // We need to transoform it to IOEither<studentsError, IOEither<printError, void>>\n      IOE.fromEither,\n      // And then flatten to the IOEither<studentsError|printError, void>\n      IOE.flatten,\n      // In case of error in "print" or "main" function return the error logger\n      IOE.getOrElse(logError)\n    )\n  )\n);\n\n// Dead Zone: executing\n\nconst run = (io: IO.IO<void>) => io();\nrun(pipe(program, T.map(run)));\n\n/**\n * Try to play around with the data and see how the app behaves\n * For example, replace the DB response with an error (uncomment the corresponding line)\n * Or make a list of students empty, or remove all students from class "A"\n * Or you can remove the element with the "app" id from the index.html\n */\n')),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"We still have not explained what a Monad is, but we used it in the description and the example. It's an advanced topic; you can explore it if you want to deepen your FP knowledge."),(0,o.kt)("p",{parentName:"admonition"},"But in straightforward terms, it's a functor with a ",(0,o.kt)("inlineCode",{parentName:"p"},"flatMap"),"(sometimes called ",(0,o.kt)("inlineCode",{parentName:"p"},"chain"),") method. ",(0,o.kt)("inlineCode",{parentName:"p"},"flatMap")," unwraps the mapping result; you might be familiar with this from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Array.prototype.flatMap"),". Yes, ",(0,o.kt)("inlineCode",{parentName:"p"},"Array")," is a monad as well!")),(0,o.kt)("h2",{id:"45-whats-the-point-of-all-of-it"},"4.5 What's the point of all of it?"),(0,o.kt)("p",null,"We have learned many things about functional programming, and let's try to answer this question: Why is FP used in the real world? Why a lot of production companies are using it? What problems does it solve?"),(0,o.kt)("p",null,"Let's look back at the procedural and OOP programming. It has many conventions, patterns, and principles; using them is the only possible way to write an extensive, growing and maintainable production-grade application. Why do they appear in the first place? Because one of the main problems with OOP - it's too low-level in the architectural sense. We control every bit of the program; we should decide how every connection would be organised and structured by ourselves. What is the result of it? We have all these MVC, SOLID, DRY, GRASP, YAGNI, KISS, and a large zoo of patterns. Their only purpose is to restrict, structure and formulate how we build applications. It's too hard to develop something in such a way without extensive experience."),(0,o.kt)("p",null,"But can functional programming resolve this problem? All these concepts are already baked into it! Let's elaborate on the most ambitious of them - SOLID."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Single Responsibility - Our functions are pure and referentially transparent; we're composing functions to create a new one and combining them in type classes. With such a restriction, we cannot even potentially make them do something different than they should."),(0,o.kt)("li",{parentName:"ol"},"Open-Closed - We have one function which does only one most primitive thing. We can create new functions via composition. We may have different base-type classes and monoids, and we can derive new ones from them. We never change the existing ones; we only extend them."),(0,o.kt)("li",{parentName:"ol"},"Liskov Substitution - The most intriguing one! All this hierarchy of type classes like Monoids, Functors and others allows us to construct programs abstractly. Does our function accept Monoid? We can pass whatever Monoid of any type we want! If our application relies on some Effect Functor, and with time we need to use another one, more performant and async - we can change it at the beginning of the program, and everything would work as expected! Because it would obey the same laws as the previous one."),(0,o.kt)("li",{parentName:"ol"},"Interface Segregation - Type classes segregated by their purpose. We might have some function that accepts the parameter of Functor, but with time we also want it to be, for example, Applicative - you're welcome, extend it, and nothing breaks!"),(0,o.kt)("li",{parentName:"ol"},"Dependency Inversion - The essence of Functional Programming. We always have absolute control over what is going on during computations. Computational flow is abstract, and every function obeys strict laws, so we can be sure of what it does by looking at its type signature.")),(0,o.kt)("p",null,"Now you can look back on the code examples and concepts we discussed, and you will see that it works! Of course, this course only gives you some theoretics and practice, and it is absolutely not enough to build something valuable in FP languages like Haskell or Scala. But the purpose was to introduce you to the world of FP, to demystify its shape, and to intrigue you to go down deep into it if you found such concepts close to you. If so, here you can see a comprehensive glossary of the most FP terms you can find on your way: ",(0,o.kt)("a",{parentName:"p",href:"https://degoes.net/articles/fp-glossary"},"https://degoes.net/articles/fp-glossary"),"."))}m.isMDXComponent=!0}}]);